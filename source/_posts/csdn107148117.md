---
title: NLP入门必知必会(一)：Word Vectors
id: csdn107148117
---

↑↑↑关注后"星标"Datawhale

每日干货 & [每月组队学习](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIyNjM2MzQyNg%3D%3D&action=getalbum&album_id=1338040906536108033#wechat_redirect)，不错过

 Datawhale干货 

**作者：芦冬生，**Datawhale优秀学习者**，北京理工大学**

自然语言处理( NLP )是信息时代最重要的技术之一，也是人工智能的重要组成部分。NLP的应用无处不在，因为人们几乎用语言交流一切：网络搜索、广告、电子邮件、客户服务、语言翻译、医疗报告等。

近年来，深度学习方法在许多不同的NLP任务中获得了非常高的性能，同时也吸引了越来越多的人加入学习NLP的大潮中。应广大学习者要求，Datawhale正式开启NLP专辑系列，提供NLP入门方向和指引，希望能帮助到大家。

本系列专辑以斯坦福的CS224N教学视频为基础，整理其课堂笔记、拓展作者的理解和学习感悟，帮助大家全面了解NLP深度学习的前沿研究。

现在，我们开启预训练模型(一)：Word vector。

本文目录：   

    1\. 人类语言和词义

*   *   如何表达一个单词的含义

    *   在计算机中如何具有可用的含义

    *   wordNet存在的问题

    *   将单词表示为离散符号

    *   单词作为离散符号存在的问题

    *   通过上下文表示单词

    *   词向量

    *   词义作为神经词向量-可视化

    2\. Word2Vec介绍

*   *   Word2Vec概述

    *   Word2Vec：目标函数

    *   带矢量的Word2Vec概述

    *   Word2Vec：预测功能

    *   通过优化参数来训练模型

    *   训练模型：计算所有矢量梯度

    3. Word2Vec梯度的导数

*   *   链式法则

    *   交互式白板会议

    *   计算所有梯度

    *   Word2vec：更多详细信息

    4. 常用工具总结

*   *   梯度下降

    *   随机梯度下降

# **一、****人类语言和词义**

![](../img/3d0b4c6a1ca93d3f8045680882a8bc32.png)

## **1.1 我们如何表示一个单词的含义？**

定义：含义（韦伯斯特词典）

*   一个词或词组表示的意思；

*   人用这个单词，符号时表达的意思；

*   一个词在写作，艺术等作品中表达意思。

最普遍的意义语言学思维方式:

*能指（符号）⟺所指（思想或事物）*

=指称语义

## **1.2 我们在计算机中如何具有可用的含义？**

常见解决方案：使用 WordNet，一个同义词库，包含同义词集和上位词列表（“是”关系）

> 例如 包含“good”的同义词集

```
# 导入初始包
# pip install nltkimport nltk
#必须下载对应的wordnet包
nltk.download('wordnet')
from nltk.corpus import wordnet as wn
poses = {'n':'noun','v':'verb','s':'adj(s)','a':'adj','r':'adv'}
for synset in wn.synsets("good"):
    print("{}:{}".format(poses[synset.pos()],",".join([l.name() for l in synset.lemmas()]))) 
```

![](../img/582b8c8cbe1e9e1cbf5017ed7ebc4ebb.png)

> 例如 "panda"的化身

```
# 导入初始包# pip install nltk
import nltk
#必须下载对应的wordnet包
nltk.download('wordnet')
from nltk.corpus import wordnet as wn
panda = wn.synset("panda.n.01")
hyper = lambda s: s.hypernyms()
list(panda.closure(hyper)) 
```

![](../img/5b9c57cc67de5bb4dfbb5ad221eae9c8.png)

## **1.3 像WordNet这样的资源，存在的问题**

*   作为资源很好，但缺少细微差别
    例如：“proficient”被列为“good”的同义词，这仅在某些情况下是正确的。

*   缺少单词的新含义
    例如,wicked,badass,nifty,wizard,genius,ninja,bombest，不可能保持最新。

*   主观

*   需要人工来创造和适应

*   无法计算准确的单词相似度

## **1.4 将单词表示为离散符号**

在传统的自然语言处理中，我们将单词视为离散符号：hotel,conference,motel - 地方代表。单词可以用one-hot向量表示：<仅一个1，其余0s>

*motel=[000000000010000]*
*hotel = [000000010000000]*

向量维数=词汇中的单词数(例如：500,000)。

## **1.5 单词作为离散符号存在的问题**

示例：在网络搜索中，如果用户搜索“Seattle motel”，我们希望匹配包含“Seattle hotel”的文档。但是：

*motel=[000000000010000]*
*hotel = [000000010000000]*

这两个向量是正交的。one-hot向量没有自然的相似性概念。

《解决方案》

*   可以尝试依靠WordNet的同义词列表来获得相似性吗？

*   *   但是众所周知严重失败：不完整等。

*   替代：学习在向量本身中编码相似性。

## **1.6 通过上下文来表示单词**

*   分布语义：一个单词的含义由经常出现的单词给出

*   *   “您将知道它所经营的公司的一句话”（J.R. Firth 1957：11）

    *   现代统计NLP最成功的想法之一！

*   当单词w出现在文本中时，其上下文是附近出现的一组单词（在固定大小的窗口内）

*   使用w的许多上下文来构建w的表示

![](../img/c9d250880bb11acc76c942b616b7daf3.png)

## **1.7 词向量**

我们将为每个单词构建一个密集的向量，并选择它，使其类似于出现在相似上下文中的单词的向量。

![](../img/832f229b7f4104254b31769d3812ddc1.png)

注意：单词向量有时也称为单词嵌入或单词表示形式，它们是分布式表示形式。

## **1.8 词义作为神经词向量-可视化**

![](../img/2a134f73b67ac0ae097f048608e282c1.png)

# **二、Word2vec介绍**

Word2vec使用两层神经网络结构来为大量文本数据的语料库生成单词的分布式表达，并在数百维向量空间中表达每个单词的特征。在该向量空间中，假设在语料库中共享公共上下文的词彼此相似，并且将向量分配给这些词，以使它们在向量空间中彼此接近。

Word2vec（Mikolov et al.2013）是用于学习单词向量的框架。想法：

*   我们有大量的语料库；

*   固定词汇表中的每个单词都由一个向量表示；

*   遍历文本中的每个位置t，该位置具有中心词c和上下文（“outside”）词o；

*   使用c和o的词向量的相似度来计算o给定c的概率（反之亦然）；

*   不断调整单词向量以最大程度地提高这种可能性。

## **2.1 Word2Vec概述**

采样窗口和计算下图的过程：

![](../img/38f9a597613fa9ff82fb3e8da137d307.png)

![](../img/5c4e8606c8a56f96c05f88aac096f6e6.png)

下一步：

![](../img/703db3a65e50420fb1e965b58b620f41.png)

## **2.2 Word2vec：目标函数**

对于每个位置 ，在给定中心词 的情况下，在固定大小 的窗口中预测上下文词。

![](../img/23a696d47246682e4878ed744da74475.png)

对于 是所有要优化的变量。

目标函数 是平均负对数似然度：< ：有时称为成本或损失函数>

![](../img/c6078a45f5240c1f16b41ab9ac8d8374.png)

*   我们想要最小化目标函数：

![](../img/b705b6568ff7539e247930eaec250a65.png)

*   问题：怎样计算

*   回答：在每个单词 我们将使用两个向量：

*   *   当 是中心词时

    *   当 是上下文词时

*   然后对于中心词c和上下文词o：

![](../img/952a2d6627310ba4934ee81df633543d.png)

## **2.3 带矢量的Word2Vec概述**

*   计算 的采样窗口和过程

*   的缩写为：

![](../img/43ea9c96fe519856845e0626aafdd032.png)

## **2.4 Word2vec：预测功能**

![](../img/25213ed9affbe0b783cf23f55b6f13f6.png)

*   这是softmax函数的一个例子：

![](../img/62c7aaf90bb26e710dadf791313a5473.png)

softmax函数将任意值 映射到概率分布

*   1\. max，因为放大了最大 的概率

*   2. soft”，因为仍然为较小的 分配了一些概率

## **2.5 通过优化参数来训练模型**

为了训练模型，我们调整参数以最大程度地减少损失。例如，对于下面两个参数的简单凸函数，等高线显示目标函数的级别。下图为等高线：

![](../img/f845a2c13dab881435c6cf79fec16f7a.png)

## **2.6 训练模型：计算所有矢量梯度！**

召回： 表示所有模型参数，在一个长矢量中。在我们以 维向量和 个单词为例的情况下：

![](../img/53855c3d35750570be2f0284bf599e79.png)

**注意**：每个词都有两个向量，我们通过沿着梯度走来优化这些参数

# **三、Word2vec梯度的导数**

此处可观看吴恩达CS224n的视频，首先给出两个公式

1\. 有用的基础知识：

![](../img/652cb275dbb44b2692532c902e22e80b.png)

2. 链式法则！如果 和 ，即 ，然后：

![](../img/f1b7498a7becb87c610558c7f44636a7.png)

## **3.1 链式法则**

链式法则！如果 和 ，即 ，然后：

![](../img/32169e8de72c0cebca59c3dafe6d6761.png)

简单的例子：

![](../img/17c5acb5a2120071fed39416b1885509.png)

*   1\. 首先，展开成y对u的函数：

![](../img/ac7aee22ffafa660d09fc52dcd47bef1.png)

*   2. 接着，y对u求导：

![](../img/c6666d6f30a64806c48eb41ee37c897e.png)

*   3\. 其次，在展开u对x的函数：

![](../img/a06af3b674616c62cd8184e63da1be0d.png)

*   4\. 接着，u对x求导：

![](../img/64652f57de84584840b4c99ca40c299a.png)

*   5\. 最后，根据链式法则：

![](../img/d90ac03a17a489f8f2ba6a5fb313a09d.png)

## **3.2 交互式白板会议！**

![](../img/7555b2fe4e2109875d89e6d0fd786aa9.png)

让我们一起得出中心词的梯度。对于一个采样窗口和一个采样外部单词：

![](../img/7458e9164fc0a9dd06f3586be185d264.png)

然后，需要为上下文单词添加梯度（类似;左侧为作业），这就是这里的所有参数 。

## **3.3 计算所有梯度！**

对一个窗口中的每个中心向量v进行了渐变，我们还需要外部向量u的梯度通常在每个窗口中，计算该窗口中正在使用的所有参数的更新，例如：

![](../img/b96e916a0e76abce09454b0aed225c85.png)

## **3.4 Word2vec：更多详细信息**

为什么要选择两个向量？->简化优化。最后将两个向量平均。Word2Vec模型有两种类型，即CBOW和skip-gram，它们均由两层神经网络组成（输入层，中间层，输出层）。

![](../img/287e21339f567982f30f9f30d0e772ff.png)

*   Continuous Bag of Words（CBOW）
    从上下文词袋中预测中心词

![](../img/b2eddeecaeb7c137c90aa7ac182fb815.png)

如上所述，CBOW根据上下文（周围的单词）预测目标单词。顺便说一句，这里使用的文本是“You can do it!”。

![](../img/addbe04230962f2e2edf83a9b354ab8c.png)

它是一个学习模型，以上下文作为输入值来最大化目标词的后验概率。大致在如上图所示的图像中，输入值以one-hot 向量的形式输入，并且在中间层获得单词的分布式表示。在此，目标词是“can”，因此检查了预测输出结果（概率）与正确答案值（1）（1-0.93）之间的差异，并通过更新权重执行学习，以使误差变小。

*   Skip-grams（SG）
    根据给定的中心词来预测上下文（“外部”）词（与位置无关）

![](../img/5b6b5fe732ff789eab8ba17bd5689d0e.png)

接下来是skip-gram，这是一个根据中心单词预测上下文（周围单词）的模型。

![](../img/739f250ed66a869be271f1334db1a159.png)

简而言之，它是反转CBOW的图像。到目前为止，我看到的两个模型都使用神经网络（它模仿人脑的神经细胞），因此当人出现带有可疑记忆的单词时考虑到有待猜测的地方，人脑可能以类似的机制主导结果。

这两种模型细节请参见：https://blog.csdn.net/dn_mug/article/details/69852740

# **四、优化：梯度下降**

我们有一个成本函数 我们想要最小化。梯度下降是最小化 的算法

**思路**：对于 的当前值，计算 的梯度，然后朝负梯度的方向走一小步。重复。<注意：我们的目标可能不会像这样凸出>

![](../img/b7801626e87d5bf035a368375651aa49.png)

## **4.1 梯度下降**

*   更新公式（以矩阵表示法）：

![](../img/2013e17259783a8c92151ee2d850b479.png)

*   更新公式（对于单个参数）：

![](../img/1bab72ae8590d5423802e99631cb516d.png)

*   算法：

```
while True:     
    theta_grad = evalute_gradient(J,corpus,theta)
    theta = theta - alpha * theta_grad 
```

## **4.2 随机梯度下降**

问题： 是语料库中所有窗口的函数（可能是数十亿！） 

*   因此 的计算非常昂贵

可能需要等待很长时间才能进行单个更新！对于几乎所有的神经网络来说，这都是一个非常糟糕的主意！

*   解决方案：随机梯度下降（SGD）

*   重复采样窗口，并在每个窗口之后进行更新

算法：

```
while True:
    window = sample_window(corpus)
    theta_grad = evaluate_gradient(J,window,theta)
    theta = theta - alpha * theta_grad 
```

**本文电子版* 后台回复 **NLP入门** 获取* 

![](../img/ac1260bd6d55ebcd4401293b8b1ef5ff.png)

“感谢你的分享，点赞，在看三**连**↓