---
title: 郁金香商业辅助教程 2016 笔记 11~15
id: csdn79339391
---

# 11 背包分析

上一节中我们发现，背包对象储存物品对象的指针，并且如果某一栏没有物品，那么那个位置就是`NULL`。我们可以以此快速寻找某个位置的地址。

比如说，我们先把第二个位置留空，在 CE 中搜索 0。搜索过程中，有些地址的数值会变化，所以多点几下“再次扫描”：

![](../img/e7b87c261f27e1277c6abbc304c3ad6c.png)

把第四个物品移到第二个，搜索比 0 大的数值：

![](../img/a65706568502e50de195f0f3234d58e8.png)

再把物品移动回去，搜索 0：

![](../img/ad91c4168910af036a92f10ccf3f756d.png)

反复几次之后，就只剩一个结果了：

![](../img/9038fa58402d668481f968d50ebfea8d.png)

我们可以验证一下。这个数值加 4 就是第三个物品的位置，再 4 就是第四个物品的位置。我们将物品 2-4 添加到底下：

![](../img/b272d27d529f007d192cf7e3ddf5fe41.png)

我们再次把第四个移到第二个，数值也会相应变化。

![](../img/e309848900624b37480b179961b10b61.png)

所以我们找对了地址。

下一步寻找背包基址，在任意一个地址上右键，“找出是什么访问了这个地址”。

![](../img/7264355fe35c1822f6abb5b694312f4b.png)

中间有几个指令，是`背包基址+物品栏偏移+物品序号*4`的形式，所以就是它们了。我们选取第一个`00656358`，背包基址应该是 EDX 的值`1b4d6238`。

这条指令上面的`31a8b3c`就是存放背包指针的地址。

然后我们挑选第三个物品`2f8eb250`，分析它的属性。切换为 ASCLL 视图：

![](../img/bdf822092692b74119c05dc9f4d04f89.png)

可以整理出一张表：

| 偏移 | 属性 |
| --- | --- |
| `0x5c` | 物品名称 |
| `0xf1` | 物品描述 |
| `0x244` | 数量 |

## 12 背包数据的封装

首先在`BaseGame.h`中定义背包基址的地址：

![](../img/cbfa50e43fe4530b5934da7196238e6e.png)

然后在`StructGame.h`中定义背包列表结构和物品结构：

![](../img/7fafd21b33eaf8a56d9869a64926e760.png)

然后在`StructGame.cpp`中实现`GetData`。先定义偏移常量：

![](../img/585eccbef0ecdfab23248396e33b6679.png)

这是`GetData`的实现：

![](../img/f92480a1a435fd8d1b479889fffa0031.png)

然后到`CMainDialogWnd.cpp`的按钮回调中，添加输出代码：

![](../img/637b9e87613b72471080050f95f67501.png)

我们可以看到输出信息：

![](../img/13f572ee87dc915d187ff03298fdd69e.png)

## 13 使用任意物品

这是第十节中的物品使用 CALL：

![](../img/e1d714a046b32743700cd3a37509563f.png)

我们用 OD 附加游戏，在这个 CALL 上下断点：

![](../img/5db27fd35e5fe009c61c6ca3a116ee8b.png)

我们发现，第一个参数是 0，第二个参数是 1，这些没有变化。唯一变化的是第三个参数，经过试验，它是物品的下标（从 0 开始）。

ECX 是前面的 EDI，在之前的分析中，它是背包基址，但它是动态分配的，和之前相比也变化了。我们用 CE 看看哪个位置存放了这个地址：

![](../img/9b37b76e25362856573373f821be30e3.png)

第一个结果就是我们第十一节中的那个地址。

编程的逻辑是这样的，我们遍历物品列表，找到金疮药的下标。然后再调用这个 CALL。

![](../img/79ef979795aa27e37be886f264b4ea66.png)

## 14 编程使用物品

首先定义物品使用 CALL 的地址：

![](../img/e34cc217d8e89ce714994ccb58654b9e.png)

在物品列表结构中定义方法`UseGoodForIndex`，它接受下标，使用指定下标处的物品：

![](../img/238559e301abf83a2d3913ce1d320558.png)

我们还需要定义一个方法，使用指定名称的物品，在此之前我们还需要一个方法`GetGoodIndexForName`，按照名称寻找物品，并返回下标：

![](../img/3ec5aa2babfb67886e45f71474e9c607.png)

然后就可以定义方法`UseGoodForName`：

![](../img/097d20d358e3b165faabb207b8385f40.png)

我们在回调中调用这个方法，然后判断结果：

![](../img/252a31d29b5b59ee2f2b686eed6d0e37.png)

可以看到物品使用成功：

![](../img/985eada449b9c20718bf59aa1a9ebb80.png)

## 15 实现自己的`TRACE`

这一节中我们要实现自己的`TRACE`。这个函数有两个特点：

*   接受格式字符串和格式化参数，格式化参数是可变的。
*   调用 API`OutputDebugStringA`，这个函数不是变参的。

思路是，我们可以用`sprintf`将输出字符串格式化好，存到一个地方。然后用它调用`OutputDebugStringA`。

但是变参函数不能调用变参函数，我们需要使用它的非变参版本`vsprintf`，它接受缓存区地址，格式字符串和格式化参数的起始地址。这就像 Java 中，编译器把可变参数放进数组中，然后再传给函数。

我们还需要用到三个宏：

*   `va_list`实际上就是`char*`，没啥特别的。
*   `va_start(p, arg)`首先将`arg`的地址加上`arg`的大小赋给`p`。实际上将`p`指向`arg`的下一个位置。
*   `va_end(p)`清空`p`。

除此之外还需要给输出字符串添加前缀，以便在工具中过滤它，这可以通过`strcat_s`实现。

这是我们所实现的函数：

![](../img/818131138d67904dee01e229345c1ff4.png)